%% LyX 2.0.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt]{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
 

\newcommand{\mb}{\mathbf}
\newcommand{\ind}{\mathbbm{1}}
\newcommand{\indfun}[1]{\ensuremath{\mb{1}_{\{#1\}}}}
 
\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


% \begin{center}
%   \textbf{\large BDSEM Package: inferring MLE rates of discretely observed birth-death-shift processes}
% \end{center}
\title{BDSEM Package: inferring MLE rates of discretely observed birth-death-shift processes}

\author{Jason Xu}

\maketitle

\section{Transition probabilities of birth-death-shift process}

Here we demonstrate how to use the software to obtain and verify the accuracy of numerically computed transition probabilities of the BDS process. We walk through an illustration that is an analogous, simplified version of the transition probability comparison experiment in the main paper. 

First, we specify desired birth, shift, and death rates $\lambda, \nu, \mu$ as inputs. Then given an initial population size $i$, corresponding to an initial state of the process $\mb{X}(0) = (i,0)$, we want to compute the transition probability $p_{(i,0),(k,l)(t)}$ accurately for any time interval length $t$. We do this for a list of different interval lengths using the function \texttt{getTrans.timeList}. This function implements our generating function approach to computing transition probabilities, and in addition to the arguments already mentioned, this requires inputs \texttt{s1.seq}, \texttt{s2.seq}, vectors of imaginary numbers evenly spaced around the unit circle. Their length determines the maximum $k,l$ values for which transition probabilities are computed; accuracy improves with finer sequences, and their length defined by \texttt{gridLength} below should be a power of $2$ for best results.

 
<<>>=
library(bdsem)
gridLength = 16
s1.seq <- exp(2*pi*1i*seq(from = 0, to = (gridLength-1))/gridLength)
s2.seq <- exp(2*pi*1i*seq(from = 0, to = (gridLength-1))/gridLength)
tList <- c(.5,2,6,10)
transProbs <- getTrans.timeList(tList, 
                                .0188, .00268, .0147, 10, s1.seq, s2.seq, .5)

@
The results are stored in \texttt{transProbs}, a list of matrices, where each entry contains a matrix corresponds to a time interval length from \texttt{tList}. The $k,l$ entry of the matrix is then the transition probability $p_{(i,0),(k-1,l-1)(t)}$

For instance, in our example the transition probability $p_{(10,0),(8,0)}(6)$ is contained in
<<>>=
transProbs[[3]][9,1]
@
since $t=6$ is the fourth entry in \texttt{tList}.

Next, we can check these probabilities by simulating from the BDS process. We simulate \texttt{nSims} realizations of the process for length $t$, for all values $t$ in \texttt{tList}. Each simulation begins at $\mb{X}(0) = (i,0)$, and transition probabilities $p_{(i,0),(k,l)(t)}$ are computed by empirically computing the proportion of times the simulation ends with $\mb{X}(t) = (k,l)$. 

These empirical transition probabilities via simulation serve as a ground truth benchmark for comparison, and are computed using \texttt{transProbs.MC}. The results are stored in the same format as returned by \texttt{getTrans.timeList}

To compare with previous methods, we can also compute the probabilities of one birth, death, or shift, as well as the probability of no event occurring, according to the frequent monitoring method: note this next section will take a while, even with a relatively small number of simulations
<<>>=
#nSims = 5000   #increase number of simulations for more precise estimates: omitted for speed
nSims = 3
transProbs.MC <- getTrans.MC(nSims,tList,.02,.008,.015,10)
transProbs.FM <- getTrans.FreqMon(tList, .02,.008,.015,10)
@

It is easy to compare entries of \texttt{transProbs} and \texttt{transProbs.MC} to verify that our method calculates accurate values. We can also plot the transition probabilities defined under frequent monitoring as computed in all three cases, similar to the more detailed figure in the main paper. Note that the Monte Carlo results may not be very accurate without increasing \texttt{nSims} in our example to an adequately large number.


<<echo=FALSE>>=
noEvent <- birthProbs <- shiftProbs <- deathProbs <- c()
sd.nothing <- sd.birth <- sd.shift <- sd.death <- c()

for(i in 1:length(tList)){
  death <- rbind( transProbs.MC[[i]][10,1], transProbs[[i]][10,1], transProbs.FM[[i]][1,1])
  shift <- rbind( transProbs.MC[[i]][10,2], transProbs[[i]][10,2], transProbs.FM[[i]][1,2])
  birth <- rbind( transProbs.MC[[i]][11,2], transProbs[[i]][11,2], transProbs.FM[[i]][2,2])
  nothing <- rbind( transProbs.MC[[i]][11,1], transProbs[[i]][11,1], transProbs.FM[[i]][2,1])
  
  sd.death <- c(sd.death, sqrt(death[1]*(1 - death[1])/nSims) )
  sd.shift <- c(sd.shift, sqrt(shift[1]*(1 - shift[1])/nSims) )
  sd.birth <- c(sd.birth, sqrt(birth[1]*(1 - birth[1])/nSims) )
  sd.nothing <- c(sd.nothing, sqrt(nothing[1]*(1 - nothing[1])/nSims) )
  
  deathProbs <- cbind(deathProbs, death)
  shiftProbs <- cbind(shiftProbs, shift)
  birthProbs <- cbind(birthProbs, birth)
  noEvent <- cbind(noEvent, nothing)
}
@

<<transFigure, echo=FALSE>>=
###PLOTTING TRANSITION RESULTS
library(plotrix)
par(mfrow=c(2,2))

plot(tList, birthProbs[3,], pch = 3, ylim = c(0,.5), col = 'purple', ylab = "Transition Probability", xlab = "Observation Interval Length", main = "Probability of One Birth")
plotCI(tList, birthProbs[1,], pch = 16, col = 4, ui=birthProbs[1,]+1.96*sd.birth, li=birthProbs[1,]-1.96*sd.birth, add = TRUE)
points(tList, birthProbs[2,], pch = 17, col=2)

plot(tList, deathProbs[3,], pch = 3, col = 'purple', ylim = c(0,.45), ylab = "Transition Probability", xlab = "Observation Interval Length", main = "Probability of One Death")
plotCI(tList, deathProbs[1,], pch = 16, col = 4, ui=deathProbs[1,]+1.96*sd.death, li=deathProbs[1,]-1.96*sd.death, add = TRUE)
points(tList, deathProbs[2,], pch = 17, col=2)

plot(tList, shiftProbs[3,], pch = 3, col = 'purple', ylim = c(0,.23), ylab = "Transition Probability", xlab = "Observation Interval Length", main = "Probability of One Shift")
plotCI(tList, shiftProbs[1,], pch = 16, col = 4, ui=shiftProbs[1,]+1.96*sd.shift, li=shiftProbs[1,]-1.96*sd.shift, add = TRUE)
points(tList, shiftProbs[2,], pch = 17, col=2)

plot(tList, noEvent[3,], pch = 3, col = 'purple', ylim = c(0,.85), ylab = "Transition Probability", xlab = "Observation Interval Length", main = "Probability of No Event")
plotCI(tList, noEvent[1,], pch = 16, col = 4, ui=noEvent[1,]+1.96*sd.nothing, li=noEvent[1,]-1.96*sd.nothing, add = TRUE)
points(tList, noEvent[2,], pch = 17, col=2)

legend("topright",legend=c("MC simulation","Frequent Monitoring", "Generating Function"), cex=.9, bty="o", col=c(4,'purple',2), pch = c(16,3,17))
@


\section{Inference in simple BDS model}

This section demonstrates how to infer birth, shift, and death rates that do not depend on covariates using our method, and can be used to recreate the second simulation study (top panel, Figure 3 of main paper) comparing inference when the likelihood is built up using transition probabilities computed using our method to the setting where frequent monitoring transition probabilities are used. 

The corresponding R code takes some time to run, and is not evaluated while compiling the vignette: you should verify that it works by copying and running the code. As discussed in the paper, we generate a partially observed dataset and infer rates using both methods. We simulate from the BSD process with parameters $\lambda = .07, \mu = .12, \nu = .2$ and record 200 discretely observed states of the process evenly spaced $dt$ time units apart. Each simulated interval begins with an initial population size drawn uniformly between $1$ and $15$, and this data generating process is repeated three times, producing three datasets corresponding to spacings $dt = (.2,.4,.6)$. The code below initializes these settings:
<<eval=FALSE>>=
#list of time interval lengths and list of possible initial sizes
tList <- c(.2,.4,.6); initList <- c(1:15)
lam = .07; v = .02; mu = .11
trueParam <- c(lam,v,mu) #simple rates, no covariates
N = 200 #number of intervals to generate per dataset

#similarly to previous example, we need to specify the grid of inputs 
gridLength = 16
s1.seq <- exp(2*pi*1i*seq(from = 0, to = (gridLength-1))/gridLength)
s2.seq <- exp(2*pi*1i*seq(from = 0, to = (gridLength-1))/gridLength)
@

The entire process of generating data and MLE inference on the synthetic dataset using our method is then completed using the function \texttt{FFT.replicate}. This function calls \texttt{makedata.simple} to generate the three synthetic datasets, and optimizes the likelihood using \texttt{optim}: because we want to compare directly to the frequent monitoring method, here we perform \textit{generic optimization}.  An example of inference using the EM algorithm follows in the next sections.
We specify necessary parameters for the algorithm described in the transition probability example above below, as well as the number of repetitions below:

<<eval=FALSE>>=
FFT.rep = 200  #number of repetitions
FFTruns <- FFT.replicate(FFT.rep, N, tList, 
                         lam, v, mu, initList, trueParam, s1.seq, s2.seq)
#the object returned by FFTruns is not intuitive, and the following code stores 
#parameter estimates and 95% confidence interval coverage in matrices a more
#readable format:
FFT.params <- vector("list",length(tList))
FFT.coverage <- mat.or.vec(3,3)
for(i in 1:length(tList)){
  FFT.params[[i]] <- sapply(FFTruns[i,], getEst)
  coverMatrix <- sapply(FFTruns[i,], getCover, trueParam = trueParam)
  FFT.coverage[i,] <- apply(coverMatrix, 1, mean)
}
@

Similarly, we may repeat the same steps using the frequent monitoring likelihood by then running the code below:
<<eval=FALSE>>=
FM.rep = 200 
system.time(FMruns <- FM.replicate(FM.rep,N,tList,lam,v,mu,initList, trueParam))

FM.params <- vector("list",length(tList))
FM.coverage <- mat.or.vec(3,3) #each row corresponds to a dt, 
#each column corresponds to a parameter coverage 
for(i in 1:length(tList)){
  FM.params[[i]] <- sapply(FMruns[i,], getEst)
  coverMatrix <- sapply(FMruns[i,], getCover, trueParam = trueParam)
  FM.coverage[i,] <- apply(coverMatrix, 1, mean)
}
@

Finally, we include some example plotting code to produce boxplots that clearly illustrate the advantage in using our method to compute transition probabilities.
<<eval=FALSE, tidy=TRUE>>=
pdf('boxPlots.pdf', width = 11, height = 4 )
par(mfrow=c(1,3))
birthplot = boxplot(xaxt = 'n', cex.lab = 1.3, ylab = "Estimate", 
                    ylim = c(.02,.127), FFT.params[[1]][1,], FM.params[[1]][1,], 
                    FFT.params[[2]][1,], FM.params[[2]][1,], FFT.params[[3]][1,], 
                    FM.params[[3]][1,], col = c(0,"grey",0,"grey",0,"grey"), 
                    main = "Birth rate estimate",cex.axis = 1.5, cex.main = 2.0, boxwex = .9)                                                                                                                                           
abline(h = lam, lty = 2)
axis(1, at=c(1.5,3.5,5.5), labels=tList, cex.axis = 1.5)
text(c(1,3,5),.123, FFT.coverage[,1], cex = 1.5)
text(c(2,4,6),.123, FM.coverage[,1], cex = 1.5)

deathplot = boxplot(xaxt = "n", cex.lab = 2, xlab = "Time Interval Length", 
                    ylim = c(.04,.202), FFT.params[[1]][3,], FM.params[[1]][3,], 
                    FFT.params[[2]][3,], FM.params[[2]][3,],  FFT.params[[3]][3,], 
                    FM.params[[3]][3,], col = c(0,"grey",0,"grey",0,"grey"), 
                    main = "Death rate estimate", cex.main = 2.0, boxwex = .9, cex.axis = 1.5)                                                                                                                                           
axis(1, at=c(1.5,3.5,5.5), labels=tList, cex.axis = 1.5)
abline(h = mu, lty = 2)
text(c(1,3,5),.197, FFT.coverage[,3], cex = 1.5)
text(c(2,4,6),.197, FM.coverage[,3], cex = 1.5)

shiftplot = boxplot(xaxt = 'n', ylim = c(0,.078), FFT.params[[1]][2,], FM.params[[1]][2,], 
                    FFT.params[[2]][2,], FM.params[[2]][2,], FFT.params[[3]][2,], FM.params[[3]][2,], 
                    col = c(0,"grey",0,"grey",0,"grey"), main = "Shift rate estimate",
                    cex.main = 2.0, cex.axis = 1.5, boxwex = .9)                                                                                                                                           
abline(h = v, lty = 2)
axis(1, at=c(1.5,3.5,5.5), labels=tList, cex.axis = 1.5)
text(c(1,3,5),.076, FFT.coverage[,2], cex = 1.5)
text(c(2,4,6),.076, FM.coverage[,2], cex = 1.5)
legend("bottomright",legend=c("FFT", "FM"), pch = c(0,15), pt.cex = 1.7, cex = 1.2, col=c(1, "grey"))

dev.off()
@


\section{Verifying Restricted Moments}
Next, we compare our restricted moment calculations to their corresponding Monte Carlo estimates. We check that the expected birth calculation is accurate, for instance, by verifying the equality
\[ E(N_t^+ | X_0 = i,j) = \sum_{k,l} E(N_t^+ , 1_{x_t = kl} | x_0 = i,j): \]

The left hand side is verified via Monte Carlo simulation, simply counting the number of births per simulation of the process for $t$ time units, and averaging over realizations. The right hand side entries are those quantities computed using our generating functions in the main theorem of the paper: we compute these over a range of $i,j$ values that comprises most of the support, and sum them to compare with the Monte Carlo averages.

The code below recreates a similar, smaller scale version of Figure 2 in the appendix:
<<>>=
lam = 10*.0188; v = 10*.0026;  mu = 10*.0147 #increase rates here just so there are not
#too many realizations with zero events, which thus requires more MC simulations
initNum = 10; param <- c(lam,v,mu)
numSims = 3 #in practice, may increase number of MC simulations

gridLength = 16
s1.seq <- exp(2*pi*1i*seq(from = 0, to = (gridLength-1))/gridLength)
s2.seq <- exp(2*pi*1i*seq(from = 0, to = (gridLength-1))/gridLength)
tList <- c(.5,1,3,5)

#compute Monte Carlo averages and empirical confidence intervals here
eventsMC <- sdsMC <- eventsFFT <- lMC <- uMC <- mat.or.vec(4, length(tList))
for(i in 1:length(tList)){
  results = sim.N.eventcount(numSims, tList[i], lam, v, mu, initNum)
  eventsMC[,i] <- rowMeans(results)
  sdsMC[,i] <- apply(results,1,sd) 
  lMC[,i] <- apply(results,1,quantile, probs = .025 )
  uMC[,i] <- apply(results, 1, quantile, probs = .975)
}

#these are lists of matrices of restricted means given ending count, list index by end time in tlist
bmeans <- getBirthMeans.timeList(tList, lam, v, mu, initNum, s1.seq, s2.seq, .5)
smeans <- getShiftMeans.timeList(tList, lam, v, mu, initNum, s1.seq, s2.seq, .5)
dmeans <- getDeathMeans.timeList(tList, lam, v, mu, initNum, s1.seq, s2.seq, .5)
ptimes <- getParticleT.timeList (tList, lam, v, mu, initNum, s1.seq, s2.seq, .5)

for(i in 1:length(tList)){
  eventsFFT[,i] <- c( sum(bmeans[[i]]), sum(smeans[[i]]), sum(dmeans[[i]]), -sum(ptimes[[i]]) )
}

#pdf('restrictedMoments.pdf')
par(mfrow=c(2,2))
plot(tList, eventsFFT[1,], pch = 1, col = 2, ylim = c(0,7.1), ylab = "Expectation", xlab = "Observation Interval Length", main = "Expected Births")
plotCI(tList, eventsMC[1,], pch = 2, col = 3, ui=eventsMC[1,]+1.96*sdsMC[1,], li=eventsMC[1,]-1.96*sdsMC[1,], add = TRUE)

plot(tList, eventsFFT[2,], pch = 1, col = 2,ylim = c(0,1.7), ylab = "Expectation", xlab = "Observation Interval Length", main = "Expected Shifts")
plotCI(tList, eventsMC[2,], pch = 2, col = 3, ui=eventsMC[2,]+1.96*sdsMC[2,], li=eventsMC[2,]-1.96*sdsMC[2,], add = TRUE)

plot(tList, eventsFFT[3,], pch = 1, col = 2, ylim = c(0,5.1), ylab = "Expectation", xlab = "Observation Interval Length", main = "Expected Deaths")
plotCI(tList, eventsMC[3,], pch = 2, col = 3, ui=eventsMC[3,]+1.96*sdsMC[3,], li=eventsMC[3,]-1.96*sdsMC[3,], add = TRUE)

plot(tList, eventsFFT[4,], pch = 1, col = 2, ylim = c(0,65), ylab = "Expectation", xlab = "Observation Interval Length", main = "Expected Particle Time")
plotCI(tList, eventsMC[4,], pch = 2, col = 3, ui=eventsMC[4,]+1.96*sdsMC[4,], li=eventsMC[4,]-1.96*sdsMC[4,], add = TRUE)
#dev.off()
@


\end{document}
